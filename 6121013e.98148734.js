(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{142:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return c})),t.d(n,"rightToc",(function(){return o})),t.d(n,"default",(function(){return b}));var a=t(1),i=t(10),r=(t(0),t(160)),l={id:"rustc",title:"Rust on a Beaglebone Blue",tags:["rust","c","cross-compile"]},c={permalink:"/rustc",editUrl:"https://github.com/afking/afking.github.io/edit/master/blog/2020-03-01-rustc.md",source:"@site/blog/2020-03-01-rustc.md",description:"Beaglebone Blue is an all-in-one linux computer for robotics. Based on the Beaglebone Black with specific integrations for robotics its the perfect dev board. In this post we wrap the extensive C libraries available to make them callable from Rust.",date:"2020-03-01T00:00:00.000Z",tags:[{label:"rust",permalink:"tags/rust"},{label:"c",permalink:"tags/c"},{label:"cross-compile",permalink:"tags/cross-compile"}],title:"Rust on a Beaglebone Blue",readingTime:3.585,truncated:!0,nextItem:{title:"Books!",permalink:"/books"}},o=[{value:"Generate C Bindings",id:"generate-c-bindings",children:[]},{value:"Linking",id:"linking",children:[]},{value:"Cross Compile",id:"cross-compile",children:[]},{value:"Calling back to Rust from C",id:"calling-back-to-rust-from-c",children:[]},{value:"Monitoring",id:"monitoring",children:[]}],s={rightToc:o};function b(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Beaglebone Blue is an all-in-one linux computer for robotics. Based on the Beaglebone Black with specific integrations for robotics its the perfect dev board. In this post we wrap the extensive C libraries available to make them callable from Rust."),Object(r.b)("p",null,Object(r.b)("img",Object(a.a)({parentName:"p"},{src:"/img/rustc/beaglebone.png",alt:"Beaglebone Blue"}))),Object(r.b)("h2",{id:"generate-c-bindings"},"Generate C Bindings"),Object(r.b)("p",null,"We need to generate C bindings to ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/StrawsonDesign/librobotcontrol"}),"librobotcontrol"),".\nThankfully Rust has fantastic tooling to autogenerate FFI C bindings with ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/rust-lang/rust-bindgen"}),"rust-bindgen"),".\nHowever we are ",Object(r.b)("em",{parentName:"p"},"not")," going to use the library feature as that requires the C libraries to be present at build. Instead we will generate the binding file ahead of time an statically link against the compiled C lib."),Object(r.b)("p",null,"Boot up the beaglebone blue and login to a shell (",Object(r.b)("inlineCode",{parentName:"p"},"mosh debian@beaglebone.local"),").\nInstall ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://rust-lang.github.io/rust-bindgen/command-line-usage.html"}),"bindgen"),".\nGit clone ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/StrawsonDesign/librobotcontrol"}),"librobotcontrol"),", running the following:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"$ git clone git@github.com:StrawsonDesign/librobotcontrol.git\n$ cd librobotcontrol\n$ bindgen include/robotcontrol.h -o bindings.rs -- -Iinclude/\n")),Object(r.b)("p",null,"If successful we now have a new file ",Object(r.b)("inlineCode",{parentName:"p"},"bindings.rs"),"!"),Object(r.b)("p",null,"Now we have bindings lets create the library to link against. Compilation is easy and all setup with the default Beaglebone Blue distribution. Compile with ",Object(r.b)("inlineCode",{parentName:"p"},"make"),". Then create an archive with ",Object(r.b)("inlineCode",{parentName:"p"},"ar"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-sh"}),"$ make\n$ ar rcs librobotcontrol.a build/**.o\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"NB: librobotcontrol is already complied in your Beaglebone distribution")),Object(r.b)("p",null,"Copy these files back to your main computer and lets move on to compiling our Rust program against this."),Object(r.b)("h2",{id:"linking"},"Linking"),Object(r.b)("p",null,"To compile our C libraries in rust we will need a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://doc.rust-lang.org/cargo/reference/build-scripts.html"}),"build script"),".\nPlacing the file ",Object(r.b)("inlineCode",{parentName:"p"},"build.rs")," in the root of a package will cause Cargo to compile the script and execute it just before building."),Object(r.b)("p",null,"With a file layout:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),".\n\u251c\u2500\u2500 build.rs\n\u251c\u2500\u2500 librobotcontrol.a\n\u251c\u2500\u2500 src\n\u2502\xa0\xa0 \u251c\u2500\u2500 main.rs\n\u2502\xa0\xa0 \u251c\u2500\u2500 bindings.rs\n.   .\n")),Object(r.b)("p",null,"Where ",Object(r.b)("inlineCode",{parentName:"p"},"bindings.rs")," and ",Object(r.b)("inlineCode",{parentName:"p"},"librobotcontrol.a")," were generated on the Beaglebone Blue."),Object(r.b)("p",null,"The build script provides the static link:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'// build.rs\nuse std::env;\nuse std::path::Path;\n\nfn main() {\n    let dir = env::var("CARGO_MANIFEST_DIR").unwrap();\n    println!("cargo:rustc-link-lib=static=robotcontrol");\n    println!(\n        "cargo:rustc-link-search=native={}",\n        Path::new(&dir).display()\n    );\n}\n')),Object(r.b)("p",null,"In ",Object(r.b)("inlineCode",{parentName:"p"},"main.rs")," we can now include our new bindings:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'// main.rs\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\ninclude!("bindings.rs");\n\n\n#[cfg(all(target_os = "linux"))]\nfn main() {\n    let c_str = unsafe {\n        let s = rc_version_string();\n        assert!(!s.is_null());\n\n        CStr::from_ptr(s)\n    };\n\n    let r_str = c_str.to_str().unwrap();\n    println!("Success version: {}!", r_str);\n}\n\n#[cfg(any(not(target_os = "linux")))]\nfn main() {\n    println!(r#"Invalid compile target!"#);\n}\n')),Object(r.b)("h2",{id:"cross-compile"},"Cross Compile"),Object(r.b)("p",null,"Our build target is the AM335x 1GHz ARM\xae Cortex-A8. To easily compile natively the Rust tools team provides ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/rust-embedded/cross"}),"cross"),". This encapsulates the required environment in docker making cross compilation easy. Install cross and build with:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cross build --target armv7-unknown-linux-gnueabihf\n")),Object(r.b)("h2",{id:"calling-back-to-rust-from-c"},"Calling back to Rust from C"),Object(r.b)("p",null,"A core part of the Robotics feature is the IMU_MPU wich includes accelerometers, gyros and barometers. The provided C library has a callback function with the following C signature:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"int rc_mpu_set_dmp_callback(void(*)(void) func)\n")),Object(r.b)("p",null,"In Rust, bingen translates this to:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'extern "C" {\n    pub fn rc_mpu_set_dmp_callback(\n        func: ::std::option::Option<unsafe extern "C" fn()>,\n    ) -> ::std::os::raw::c_int;\n}\n')),Object(r.b)("p",null,"To call back into Rust from C code we need to provide a function which compiles to C's ABI. Unfortunately closures aren't able to provide this without a ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://blog.seantheprogrammer.com/neat-rust-tricks-passing-rust-closures-to-c"}),"trampoline function"),". However, the provided C API doesn't allow this trampolining as the arguments aren't passed in the callback. We therefore resort to using global state, breaking the Rust thread safety guarantees. Each function that touches this memory will need to be wrapped in unsafe."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'static mut mpu_data: rc_mpu_data_t = rc_mpu_data_t {\n    accel: [0.0; 3usize],\n    gyro: [0.0; 3usize],\n    mag: [0.0; 3usize],\n    temp: 0.0,\n    ...\n};\n\nunsafe extern "C" fn mpu_callback() {\n    // Read access is only safe in this function.\n    println!("Acceleration: {}!", mpu_data.accel);\n}\n')),Object(r.b)("p",null,"Where the function can be registered with:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),"    unsafe { rc_mpu_set_dmp_callback(Some(mpu_callback)) };\n")),Object(r.b)("h2",{id:"monitoring"},"Monitoring"),Object(r.b)("p",null,"As a quick demonstration we can expose these metrics via Promethues. Create a GuageVec for acceleration. On each callback update the guage parameters for all 3 dimensions x, y and z:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rust"}),'lazy_static! {\n    static ref ACCELERATION: GaugeVec =\n        register_gauge_vec!("acceleration", "Acceleration in m/s^2", &["dimension"]).unwrap();\n}\n\nunsafe extern "C" fn mpu_callback() {\n    ACCELERATION\n        .with_label_values(&["x"])\n        .set(mpu_data.accel[0]);\n    ACCELERATION\n        .with_label_values(&["y"])\n        .set(mpu_data.accel[1]);\n    ACCELERATION\n        .with_label_values(&["z"])\n        .set(mpu_data.accel[2]);\n}\n')),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"NB: MPU acceleration values should be filtered.")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'# HELP acceleration Acceleration in m/s^2\n# TYPE acceleration gauge\nacceleration{dimension="x"} 8.169016064453125\nacceleration{dimension="y"} -0.3399766357421875\nacceleration{dimension="z"} 5.616797094726562\n')),Object(r.b)("p",null,Object(r.b)("img",Object(a.a)({parentName:"p"},{src:"/img/rustc/grafana.png",alt:"Grafana image"}))),Object(r.b)("p",null,"We now have our Rust program wrapping an ARM C library enabling easy access to all Beaglebone Blues peripherals!"))}b.isMDXComponent=!0}}]);